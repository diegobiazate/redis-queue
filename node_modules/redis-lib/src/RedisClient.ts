import Redis, { RedisOptions } from 'ioredis';

type RedisMode = 'pubsub' | 'queue' | 'stream';

interface RedisClientOptions {
  mode?: RedisMode; // Define o modo de operação
  connectionOptions: string | RedisOptions; // Configuração do Redis
}

export class RedisClient {
  private client: Redis; // Cliente padrão para operações gerais (get/set, filas, streams)
  private subscriber?: Redis; // Cliente dedicado para subscrição (Pub/Sub)
  private mode: RedisMode;

  constructor({connectionOptions, mode}: RedisClientOptions) {
    this.mode = mode || 'pubsub';
    if(typeof connectionOptions === 'string'){
      this.client = new Redis(connectionOptions);
      if (this.mode === 'pubsub') {
        this.subscriber = new Redis(connectionOptions);
      }
    }else {
      this.client = new Redis(connectionOptions);
      if (this.mode === 'pubsub') {
        this.subscriber = new Redis(connectionOptions);
      }
    }

  }

  // ==== Métodos Simples: Get/Set ====

  /**
   * Define um valor no Redis.
   * @param key Chave do valor.
   * @param value Valor a ser armazenado.
   * @param expiration (opcional) Tempo de expiração em segundos.
   */
  async set(key: string, value: string, expiration?: number): Promise<void> {
    if (expiration) {
      await this.client.set(key, value, 'EX', expiration);
    } else {
      await this.client.set(key, value);
    }
  }

  /**
   * Obtém um valor do Redis.
   * @param key Chave a ser consultada.
   * @returns Valor armazenado ou null.
   */
  async get(key: string): Promise<string | null> {
    return this.client.get(key);
  }

  // ==== Métodos Pub/Sub ====

  /**
   * Publica uma mensagem em um canal.
   * @param channel Nome do canal.
   * @param message Mensagem a ser publicada.
   */
  async publish(channel: string, message: string): Promise<void> {
    await this.client.publish(channel, message);
  }

  /**
   * Inscreve-se em um canal para receber mensagens.
   * @param channel Nome do canal.
   * @param callback Função de callback chamada com cada mensagem recebida.
   */
  async subscribe(channel: string, callback: (message: string) => void): Promise<void> {
    if (!this.subscriber) {
      throw new Error('Pub/Sub mode is not enabled.');
    }

    await this.subscriber.subscribe(channel);
    this.subscriber.on('message', (_channel, message) => {
      if (_channel === channel) {
        callback(message);
      }
    });
  }

  // ==== Métodos para Filas (Lists) ====

  /**
   * Adiciona uma mensagem à fila.
   * @param queueName Nome da fila.
   * @param message Mensagem a ser adicionada.
   */
  async pushToQueue(queueName: string, message: string): Promise<void> {
    await this.client.rpush(queueName, message);
  }

  /**
   * Consome uma mensagem da fila de forma bloqueante.
   * @param queueName Nome da fila.
   * @param timeout (opcional) Tempo de espera em segundos.
   * @returns Mensagem consumida ou null.
   */
  async popFromQueue(queueName: string, timeout: number = 0): Promise<string | null> {
    const result = await this.client.blpop(queueName, timeout);
    return result ? result[1] : null;
  }

  // ==== Métodos para Streams ====

  /**
   * Adiciona uma mensagem ao stream.
   * @param streamName Nome do stream.
   * @param message Objeto contendo os campos e valores da mensagem.
   */
  async addToStream(streamName: string, message: Record<string, string>): Promise<void> {
    await this.client.xadd(streamName, '*', ...Object.entries(message).flat());
  }

  /**
   * Cria um grupo de consumidores para um stream.
   * @param streamName Nome do stream.
   * @param groupName Nome do grupo de consumidores.
   */
  async createConsumerGroup(streamName: string, groupName: string): Promise<void> {
    try {
      await this.client.xgroup('CREATE', streamName, groupName, '$', 'MKSTREAM');
    } catch (err: any) {
      if (!err.message.includes('BUSYGROUP')) {
        throw err;
      }
    }
  }

  /**
   * Lê mensagens de um grupo de consumidores.
   * @param streamName Nome do stream.
   * @param groupName Nome do grupo de consumidores.
   * @param consumerName Nome do consumidor.
   * @param count (opcional) Número máximo de mensagens a serem lidas.
   * @param block (opcional) Tempo de bloqueio em milissegundos.
   * @returns Lista de mensagens lidas.
   */
  async readFromStream(
    streamName: string,
    groupName: string,
    consumerName: string,
    count: number = 1,
    block: number = 0
  ): Promise<any[]> {
    const messages = await this.client.xreadgroup(
      'GROUP',
      groupName,
      consumerName,
      'COUNT',
      count,
      'BLOCK',
      block,
      'STREAMS',
      streamName,
      '>'
    );
    return messages || [];
  }

  // ==== Métodos de Limpeza ====

  /**
   * Fecha todas as conexões Redis.
   */
  async close(): Promise<void> {
    await this.client.quit();
    if (this.subscriber) {
      await this.subscriber.quit();
    }
  }
}
